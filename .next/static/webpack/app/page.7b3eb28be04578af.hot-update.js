"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/game-logic.ts":
/*!***************************!*\
  !*** ./lib/game-logic.ts ***!
  \***************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GAME_CONFIG: () => (/* binding */ GAME_CONFIG),\n/* harmony export */   gameLogic: () => (/* binding */ gameLogic)\n/* harmony export */ });\n// Updated game config for DRX mining system\nconst GAME_CONFIG = {\n    REFERRAL_BONUS: 200,\n    BASE_MINING_RATE: 0.001,\n    WELCOME_BONUS: 100,\n    JACKPOT_COOLDOWN: 3600000,\n    MIN_CLAIM_TIME: 1800,\n    MAX_MINING_TIME: 86400,\n    DAILY_MINING_REWARD: 100,\n    CRITICAL_CHANCE: 0.02,\n    JACKPOT_CHANCE: 0.0005,\n    MAX_LEVEL: 50,\n    XP_PER_LEVEL: 100,\n    DRX_TO_UC_RATE: 1,\n    BASE_XP_REWARD: 50,\n    REFERRAL_XP_BONUS: 60\n};\nconst gameLogic = {\n    calculateMiningRewards (user, miningDuration) {\n        const baseRate = user.miningRate || GAME_CONFIG.BASE_MINING_RATE;\n        let earned = baseRate * miningDuration // duration in seconds\n        ;\n        let type = \"normal\";\n        // Calculate XP based on mining duration (30 minutes = 30 XP base)\n        let xp = Math.floor(miningDuration / 1800 * GAME_CONFIG.BASE_XP_REWARD) // 1800 seconds = 30 minutes\n        ;\n        // Apply boost multipliers to XP\n        const miningSpeedMultiplier = user.boosts.miningSpeedLevel || 1;\n        const miningRateMultiplier = user.boosts.miningRateLevel || 1;\n        xp = Math.floor(xp * Math.max(miningSpeedMultiplier, miningRateMultiplier) * 0.5);\n        // Bonus for 24h continuous mining\n        if (miningDuration >= GAME_CONFIG.MAX_MINING_TIME) {\n            earned += GAME_CONFIG.DAILY_MINING_REWARD;\n            xp += 100 // Bonus XP for 24h mining\n            ;\n            type = \"bonus\";\n        }\n        return {\n            earned,\n            type,\n            xp\n        };\n    },\n    calculateLevel (xp) {\n        let level = 1;\n        let remainingXP = xp;\n        let totalXPNeeded = 0;\n        while(remainingXP >= this.getXpForLevel(level)){\n            const xpForThisLevel = this.getXpForLevel(level);\n            remainingXP -= xpForThisLevel;\n            totalXPNeeded += xpForThisLevel;\n            level++;\n        }\n        return {\n            level,\n            currentXP: remainingXP,\n            xpForNext: this.getXpForLevel(level)\n        };\n    },\n    getXpForLevel (level) {\n        if (level === 1) return 100;\n        // Each level requires more XP progressively\n        return 100 + (level - 1) * 50;\n    },\n    calculateRank (totalEarned) {\n        var _ranks_;\n        const ranks = [\n            {\n                threshold: 0,\n                title: \"Rookie Miner\",\n                icon: \"ü•â\"\n            },\n            {\n                threshold: 1000,\n                title: \"Bronze Miner\",\n                icon: \"ü•â\"\n            },\n            {\n                threshold: 5000,\n                title: \"Silver Miner\",\n                icon: \"ü•à\"\n            },\n            {\n                threshold: 15000,\n                title: \"Gold Miner\",\n                icon: \"ü•á\"\n            },\n            {\n                threshold: 50000,\n                title: \"Platinum Miner\",\n                icon: \"üíé\"\n            },\n            {\n                threshold: 150000,\n                title: \"Diamond Miner\",\n                icon: \"üíé\"\n            },\n            {\n                threshold: 500000,\n                title: \"Master Miner\",\n                icon: \"üëë\"\n            },\n            {\n                threshold: 1500000,\n                title: \"Grandmaster Miner\",\n                icon: \"üëë\"\n            },\n            {\n                threshold: 5000000,\n                title: \"Legend Miner\",\n                icon: \"üèÜ\"\n            },\n            {\n                threshold: 15000000,\n                title: \"Mythical Miner\",\n                icon: \"‚≠ê\"\n            },\n            {\n                threshold: 50000000,\n                title: \"Ultimate Miner\",\n                icon: \"üåü\"\n            }\n        ];\n        let currentRank = 1;\n        let currentTitle = ranks[0].title;\n        let currentIcon = ranks[0].icon;\n        let nextRankAt = ((_ranks_ = ranks[1]) === null || _ranks_ === void 0 ? void 0 : _ranks_.threshold) || 0;\n        for(let i = 0; i < ranks.length; i++){\n            if (totalEarned >= ranks[i].threshold) {\n                var _ranks_1;\n                currentRank = i + 1;\n                currentTitle = ranks[i].title;\n                currentIcon = ranks[i].icon;\n                nextRankAt = ((_ranks_1 = ranks[i + 1]) === null || _ranks_1 === void 0 ? void 0 : _ranks_1.threshold) || ranks[i].threshold;\n            } else {\n                break;\n            }\n        }\n        return {\n            rank: currentRank,\n            title: currentTitle,\n            nextRankAt,\n            icon: currentIcon\n        };\n    },\n    getBoostCost (boostType, currentLevel) {\n        const baseCost = GAME_CONFIG.BOOST_BASE_COSTS[boostType];\n        // Each level costs more than the previous, starting from level 1\n        return Math.floor(baseCost * Math.pow(GAME_CONFIG.BOOST_COST_MULTIPLIER, Math.max(0, currentLevel - 1)));\n    },\n    getNextBoostValue (boostType, currentLevel, user) {\n        switch(boostType){\n            case \"miningSpeed\":\n                const nextSpeedMultiplier = currentLevel + 1;\n                return \"\".concat(nextSpeedMultiplier, \"x\");\n            case \"claimTime\":\n                const currentTime = user.minClaimTime || GAME_CONFIG.MIN_CLAIM_TIME;\n                const nextTime = Math.max(300, currentTime - 300) // Reduce by 5 minutes, minimum 5 minutes\n                ;\n                return this.formatTime(nextTime);\n            case \"miningRate\":\n                const currentRate = user.miningRate || GAME_CONFIG.BASE_MINING_RATE;\n                const nextRate = currentRate * 1.5;\n                return \"\".concat(this.formatNumberPrecise(nextRate), \"/s\");\n            default:\n                return \"Unknown\";\n        }\n    },\n    formatNumber (num) {\n        const safeNum = typeof num === \"number\" && !isNaN(num) ? num : 0;\n        if (safeNum >= 1000000000) {\n            return Math.floor(safeNum / 1000000000) + \"B\";\n        } else if (safeNum >= 1000000) {\n            return Math.floor(safeNum / 1000000) + \"M\";\n        } else if (safeNum >= 1000) {\n            return Math.floor(safeNum / 1000) + \"K\";\n        }\n        return Math.floor(safeNum).toString();\n    },\n    formatNumberPrecise (num) {\n        const safeNum = typeof num === \"number\" && !isNaN(num) ? num : 0;\n        // Remove trailing zeros and unnecessary decimal places\n        if (safeNum === 0) return \"0\";\n        if (safeNum >= 1) return safeNum.toFixed(3).replace(/\\.?0+$/, \"\");\n        return safeNum.toFixed(6).replace(/\\.?0+$/, \"\");\n    },\n    formatTime (seconds) {\n        const safeSeconds = typeof seconds === \"number\" && !isNaN(seconds) ? Math.floor(seconds) : 0;\n        const hours = Math.floor(safeSeconds / 3600);\n        const minutes = Math.floor(safeSeconds % 3600 / 60);\n        const secs = safeSeconds % 60;\n        if (hours > 0) {\n            return \"\".concat(hours.toString().padStart(2, '0'), \":\").concat(minutes.toString().padStart(2, '0'), \":\").concat(secs.toString().padStart(2, '0'));\n        } else {\n            return \"\".concat(minutes.toString().padStart(2, '0'), \":\").concat(secs.toString().padStart(2, '0'));\n        }\n    },\n    canClaimMining (user) {\n        if (!user.isMining || !user.miningStartTime) return false;\n        const now = Date.now();\n        const miningDuration = Math.floor((now - user.miningStartTime) / 1000);\n        return miningDuration >= (user.minClaimTime || GAME_CONFIG.MIN_CLAIM_TIME);\n    },\n    getMiningDuration (user) {\n        if (!user.isMining || !user.miningStartTime) return 0;\n        const now = Date.now();\n        return Math.floor((now - user.miningStartTime) / 1000);\n    },\n    calculatePendingRewards (user) {\n        const duration = this.getMiningDuration(user);\n        if (duration === 0) return 0;\n        const { earned } = this.calculateMiningRewards(user, duration);\n        return earned;\n    },\n    getRemainingClaimTime (user) {\n        if (!user.isMining || !user.miningStartTime) return 0;\n        const now = Date.now();\n        const miningDuration = Math.floor((now - user.miningStartTime) / 1000);\n        const minTime = user.minClaimTime || GAME_CONFIG.MIN_CLAIM_TIME;\n        return Math.max(0, minTime - miningDuration);\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUMsQ0FBQzRELE1BQU1wRSxLQUFLbUUsZUFBZSxJQUFJO0lBQ25EO0lBRUFJLHlCQUF3QnZFLElBQVU7UUFDaEMsTUFBTXdFLFdBQVcsSUFBSSxDQUFDRixpQkFBaUIsQ0FBQ3RFO1FBQ3hDLElBQUl3RSxhQUFhLEdBQUcsT0FBTztRQUUzQixNQUFNLEVBQUVwRSxNQUFNLEVBQUUsR0FBRyxJQUFJLENBQUNMLHNCQUFzQixDQUFDQyxNQUFNd0U7UUFDckQsT0FBT3BFO0lBQ1Q7SUFFQXFFLHVCQUFzQnpFLElBQVU7UUFDOUIsSUFBSSxDQUFDQSxLQUFLa0UsUUFBUSxJQUFJLENBQUNsRSxLQUFLbUUsZUFBZSxFQUFFLE9BQU87UUFFcEQsTUFBTUMsTUFBTUMsS0FBS0QsR0FBRztRQUNwQixNQUFNbkUsaUJBQWlCTSxLQUFLQyxLQUFLLENBQUMsQ0FBQzRELE1BQU1wRSxLQUFLbUUsZUFBZSxJQUFJO1FBQ2pFLE1BQU1PLFVBQVUxRSxLQUFLOEMsWUFBWSxJQUFJL0QsWUFBWUssY0FBYztRQUUvRCxPQUFPbUIsS0FBS08sR0FBRyxDQUFDLEdBQUc0RCxVQUFVekU7SUFDL0I7QUFDRixFQUFDIiwic291cmNlcyI6WyIvaG9tZS9wcm9qZWN0L2xpYi9nYW1lLWxvZ2ljLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgVXNlciB9IGZyb20gXCJAL3R5cGVzXCJcblxuLy8gVXBkYXRlZCBnYW1lIGNvbmZpZyBmb3IgRFJYIG1pbmluZyBzeXN0ZW1cbmV4cG9ydCBjb25zdCBHQU1FX0NPTkZJRyA9IHtcbiAgUkVGRVJSQUxfQk9OVVM6IDIwMCwgLy8gRFJYXG4gIEJBU0VfTUlOSU5HX1JBVEU6IDAuMDAxLCAvLyBEUlggcGVyIHNlY29uZFxuICBXRUxDT01FX0JPTlVTOiAxMDAsIC8vIERSWFxuICBKQUNLUE9UX0NPT0xET1dOOiAzNjAwMDAwLCAvLyAxIGhvdXJcbiAgTUlOX0NMQUlNX1RJTUU6IDE4MDAsIC8vIDMwIG1pbnV0ZXMgbWluaW11bSBtaW5pbmcgdGltZVxuICBNQVhfTUlOSU5HX1RJTUU6IDg2NDAwLCAvLyAyNCBob3VycyBtYXhpbXVtIG1pbmluZyB0aW1lXG4gIERBSUxZX01JTklOR19SRVdBUkQ6IDEwMCwgLy8gRFJYIGZvciAzMG1pbiBjb250aW51b3VzIG1pbmluZ1xuICBDUklUSUNBTF9DSEFOQ0U6IDAuMDIsXG4gIEpBQ0tQT1RfQ0hBTkNFOiAwLjAwMDUsXG4gIE1BWF9MRVZFTDogNTAsXG4gIFhQX1BFUl9MRVZFTDogMTAwLFxuICBEUlhfVE9fVUNfUkFURTogMSwgLy8gMSBEUlggPSAxIFVDIChjYW4gYmUgY2hhbmdlZClcbiAgQkFTRV9YUF9SRVdBUkQ6IDUwLCAvLyBCYXNlIFhQIGZvciAzMCBtaW51dGVzIG9mIG1pbmluZ1xuICBSRUZFUlJBTF9YUF9CT05VUzogNjAsIC8vIFhQIGJvbnVzIGZvciByZWZlcnJhbHNcbn1cblxuZXhwb3J0IGNvbnN0IGdhbWVMb2dpYyA9IHtcbiAgY2FsY3VsYXRlTWluaW5nUmV3YXJkcyh1c2VyOiBVc2VyLCBtaW5pbmdEdXJhdGlvbjogbnVtYmVyKTogeyBlYXJuZWQ6IG51bWJlcjsgdHlwZTogXCJub3JtYWxcIiB8IFwiYm9udXNcIjsgeHA6IG51bWJlciB9IHtcbiAgICBjb25zdCBiYXNlUmF0ZSA9IHVzZXIubWluaW5nUmF0ZSB8fCBHQU1FX0NPTkZJRy5CQVNFX01JTklOR19SQVRFXG4gICAgbGV0IGVhcm5lZCA9IGJhc2VSYXRlICogbWluaW5nRHVyYXRpb24gLy8gZHVyYXRpb24gaW4gc2Vjb25kc1xuICAgIGxldCB0eXBlOiBcIm5vcm1hbFwiIHwgXCJib251c1wiID0gXCJub3JtYWxcIlxuICAgIFxuICAgIC8vIENhbGN1bGF0ZSBYUCBiYXNlZCBvbiBtaW5pbmcgZHVyYXRpb24gKDMwIG1pbnV0ZXMgPSAzMCBYUCBiYXNlKVxuICAgIGxldCB4cCA9IE1hdGguZmxvb3IoKG1pbmluZ0R1cmF0aW9uIC8gMTgwMCkgKiBHQU1FX0NPTkZJRy5CQVNFX1hQX1JFV0FSRCkgLy8gMTgwMCBzZWNvbmRzID0gMzAgbWludXRlc1xuICAgIFxuICAgIC8vIEFwcGx5IGJvb3N0IG11bHRpcGxpZXJzIHRvIFhQXG4gICAgY29uc3QgbWluaW5nU3BlZWRNdWx0aXBsaWVyID0gdXNlci5ib29zdHMubWluaW5nU3BlZWRMZXZlbCB8fCAxXG4gICAgY29uc3QgbWluaW5nUmF0ZU11bHRpcGxpZXIgPSB1c2VyLmJvb3N0cy5taW5pbmdSYXRlTGV2ZWwgfHwgMVxuICAgIHhwID0gTWF0aC5mbG9vcih4cCAqIE1hdGgubWF4KG1pbmluZ1NwZWVkTXVsdGlwbGllciwgbWluaW5nUmF0ZU11bHRpcGxpZXIpICogMC41KVxuXG4gICAgLy8gQm9udXMgZm9yIDI0aCBjb250aW51b3VzIG1pbmluZ1xuICAgIGlmIChtaW5pbmdEdXJhdGlvbiA+PSBHQU1FX0NPTkZJRy5NQVhfTUlOSU5HX1RJTUUpIHtcbiAgICAgIGVhcm5lZCArPSBHQU1FX0NPTkZJRy5EQUlMWV9NSU5JTkdfUkVXQVJEXG4gICAgICB4cCArPSAxMDAgLy8gQm9udXMgWFAgZm9yIDI0aCBtaW5pbmdcbiAgICAgIHR5cGUgPSBcImJvbnVzXCJcbiAgICB9XG5cbiAgICByZXR1cm4geyBlYXJuZWQsIHR5cGUsIHhwIH1cbiAgfSxcblxuICBjYWxjdWxhdGVMZXZlbCh4cDogbnVtYmVyKTogeyBsZXZlbDogbnVtYmVyOyBjdXJyZW50WFA6IG51bWJlcjsgeHBGb3JOZXh0OiBudW1iZXIgfSB7XG4gICAgbGV0IGxldmVsID0gMVxuICAgIGxldCByZW1haW5pbmdYUCA9IHhwXG4gICAgbGV0IHRvdGFsWFBOZWVkZWQgPSAwXG5cbiAgICB3aGlsZSAocmVtYWluaW5nWFAgPj0gdGhpcy5nZXRYcEZvckxldmVsKGxldmVsKSkge1xuICAgICAgY29uc3QgeHBGb3JUaGlzTGV2ZWwgPSB0aGlzLmdldFhwRm9yTGV2ZWwobGV2ZWwpXG4gICAgICByZW1haW5pbmdYUCAtPSB4cEZvclRoaXNMZXZlbFxuICAgICAgdG90YWxYUE5lZWRlZCArPSB4cEZvclRoaXNMZXZlbFxuICAgICAgbGV2ZWwrK1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBsZXZlbCxcbiAgICAgIGN1cnJlbnRYUDogcmVtYWluaW5nWFAsXG4gICAgICB4cEZvck5leHQ6IHRoaXMuZ2V0WHBGb3JMZXZlbChsZXZlbCksXG4gICAgfVxuICB9LFxuXG4gIGdldFhwRm9yTGV2ZWwobGV2ZWw6IG51bWJlcik6IG51bWJlciB7XG4gICAgaWYgKGxldmVsID09PSAxKSByZXR1cm4gMTAwXG4gICAgLy8gRWFjaCBsZXZlbCByZXF1aXJlcyBtb3JlIFhQIHByb2dyZXNzaXZlbHlcbiAgICByZXR1cm4gMTAwICsgKGxldmVsIC0gMSkgKiA1MFxuICB9LFxuXG4gIGNhbGN1bGF0ZVJhbmsodG90YWxFYXJuZWQ6IG51bWJlcik6IHsgcmFuazogbnVtYmVyOyB0aXRsZTogc3RyaW5nOyBuZXh0UmFua0F0OiBudW1iZXI7IGljb246IHN0cmluZyB9IHtcbiAgICBjb25zdCByYW5rcyA9IFtcbiAgICAgIHsgdGhyZXNob2xkOiAwLCB0aXRsZTogXCJSb29raWUgTWluZXJcIiwgaWNvbjogXCLwn6WJXCIgfSxcbiAgICAgIHsgdGhyZXNob2xkOiAxMDAwLCB0aXRsZTogXCJCcm9uemUgTWluZXJcIiwgaWNvbjogXCLwn6WJXCIgfSxcbiAgICAgIHsgdGhyZXNob2xkOiA1MDAwLCB0aXRsZTogXCJTaWx2ZXIgTWluZXJcIiwgaWNvbjogXCLwn6WIXCIgfSxcbiAgICAgIHsgdGhyZXNob2xkOiAxNTAwMCwgdGl0bGU6IFwiR29sZCBNaW5lclwiLCBpY29uOiBcIvCfpYdcIiB9LFxuICAgICAgeyB0aHJlc2hvbGQ6IDUwMDAwLCB0aXRsZTogXCJQbGF0aW51bSBNaW5lclwiLCBpY29uOiBcIvCfko5cIiB9LFxuICAgICAgeyB0aHJlc2hvbGQ6IDE1MDAwMCwgdGl0bGU6IFwiRGlhbW9uZCBNaW5lclwiLCBpY29uOiBcIvCfko5cIiB9LFxuICAgICAgeyB0aHJlc2hvbGQ6IDUwMDAwMCwgdGl0bGU6IFwiTWFzdGVyIE1pbmVyXCIsIGljb246IFwi8J+RkVwiIH0sXG4gICAgICB7IHRocmVzaG9sZDogMTUwMDAwMCwgdGl0bGU6IFwiR3JhbmRtYXN0ZXIgTWluZXJcIiwgaWNvbjogXCLwn5GRXCIgfSxcbiAgICAgIHsgdGhyZXNob2xkOiA1MDAwMDAwLCB0aXRsZTogXCJMZWdlbmQgTWluZXJcIiwgaWNvbjogXCLwn4+GXCIgfSxcbiAgICAgIHsgdGhyZXNob2xkOiAxNTAwMDAwMCwgdGl0bGU6IFwiTXl0aGljYWwgTWluZXJcIiwgaWNvbjogXCLirZBcIiB9LFxuICAgICAgeyB0aHJlc2hvbGQ6IDUwMDAwMDAwLCB0aXRsZTogXCJVbHRpbWF0ZSBNaW5lclwiLCBpY29uOiBcIvCfjJ9cIiB9LFxuICAgIF1cblxuICAgIGxldCBjdXJyZW50UmFuayA9IDFcbiAgICBsZXQgY3VycmVudFRpdGxlID0gcmFua3NbMF0udGl0bGVcbiAgICBsZXQgY3VycmVudEljb24gPSByYW5rc1swXS5pY29uXG4gICAgbGV0IG5leHRSYW5rQXQgPSByYW5rc1sxXT8udGhyZXNob2xkIHx8IDBcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmFua3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0b3RhbEVhcm5lZCA+PSByYW5rc1tpXS50aHJlc2hvbGQpIHtcbiAgICAgICAgY3VycmVudFJhbmsgPSBpICsgMVxuICAgICAgICBjdXJyZW50VGl0bGUgPSByYW5rc1tpXS50aXRsZVxuICAgICAgICBjdXJyZW50SWNvbiA9IHJhbmtzW2ldLmljb25cbiAgICAgICAgbmV4dFJhbmtBdCA9IHJhbmtzW2kgKyAxXT8udGhyZXNob2xkIHx8IHJhbmtzW2ldLnRocmVzaG9sZFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgcmFuazogY3VycmVudFJhbmssXG4gICAgICB0aXRsZTogY3VycmVudFRpdGxlLFxuICAgICAgbmV4dFJhbmtBdCxcbiAgICAgIGljb246IGN1cnJlbnRJY29uLFxuICAgIH1cbiAgfSxcblxuICBnZXRCb29zdENvc3QoYm9vc3RUeXBlOiBcIm1pbmluZ1NwZWVkXCIgfCBcImNsYWltVGltZVwiIHwgXCJtaW5pbmdSYXRlXCIsIGN1cnJlbnRMZXZlbDogbnVtYmVyKTogbnVtYmVyIHtcbiAgICBjb25zdCBiYXNlQ29zdCA9IEdBTUVfQ09ORklHLkJPT1NUX0JBU0VfQ09TVFNbYm9vc3RUeXBlXVxuICAgIC8vIEVhY2ggbGV2ZWwgY29zdHMgbW9yZSB0aGFuIHRoZSBwcmV2aW91cywgc3RhcnRpbmcgZnJvbSBsZXZlbCAxXG4gICAgcmV0dXJuIE1hdGguZmxvb3IoYmFzZUNvc3QgKiBNYXRoLnBvdyhHQU1FX0NPTkZJRy5CT09TVF9DT1NUX01VTFRJUExJRVIsIE1hdGgubWF4KDAsIGN1cnJlbnRMZXZlbCAtIDEpKSlcbiAgfSxcblxuICBnZXROZXh0Qm9vc3RWYWx1ZShib29zdFR5cGU6IFwibWluaW5nU3BlZWRcIiB8IFwiY2xhaW1UaW1lXCIgfCBcIm1pbmluZ1JhdGVcIiwgY3VycmVudExldmVsOiBudW1iZXIsIHVzZXI6IFVzZXIpOiBzdHJpbmcge1xuICAgIHN3aXRjaCAoYm9vc3RUeXBlKSB7XG4gICAgICBjYXNlIFwibWluaW5nU3BlZWRcIjpcbiAgICAgICAgY29uc3QgbmV4dFNwZWVkTXVsdGlwbGllciA9IGN1cnJlbnRMZXZlbCArIDFcbiAgICAgICAgcmV0dXJuIGAke25leHRTcGVlZE11bHRpcGxpZXJ9eGBcbiAgICAgIGNhc2UgXCJjbGFpbVRpbWVcIjpcbiAgICAgICAgY29uc3QgY3VycmVudFRpbWUgPSB1c2VyLm1pbkNsYWltVGltZSB8fCBHQU1FX0NPTkZJRy5NSU5fQ0xBSU1fVElNRVxuICAgICAgICBjb25zdCBuZXh0VGltZSA9IE1hdGgubWF4KDMwMCwgY3VycmVudFRpbWUgLSAzMDApIC8vIFJlZHVjZSBieSA1IG1pbnV0ZXMsIG1pbmltdW0gNSBtaW51dGVzXG4gICAgICAgIHJldHVybiB0aGlzLmZvcm1hdFRpbWUobmV4dFRpbWUpXG4gICAgICBjYXNlIFwibWluaW5nUmF0ZVwiOlxuICAgICAgICBjb25zdCBjdXJyZW50UmF0ZSA9IHVzZXIubWluaW5nUmF0ZSB8fCBHQU1FX0NPTkZJRy5CQVNFX01JTklOR19SQVRFXG4gICAgICAgIGNvbnN0IG5leHRSYXRlID0gY3VycmVudFJhdGUgKiAxLjVcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuZm9ybWF0TnVtYmVyUHJlY2lzZShuZXh0UmF0ZSl9L3NgXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gXCJVbmtub3duXCJcbiAgICB9XG4gIH0sXG5cbiAgZm9ybWF0TnVtYmVyKG51bTogbnVtYmVyIHwgdW5kZWZpbmVkIHwgbnVsbCk6IHN0cmluZyB7XG4gICAgY29uc3Qgc2FmZU51bSA9IHR5cGVvZiBudW0gPT09IFwibnVtYmVyXCIgJiYgIWlzTmFOKG51bSkgPyBudW0gOiAwXG5cbiAgICBpZiAoc2FmZU51bSA+PSAxMDAwMDAwMDAwKSB7XG4gICAgICByZXR1cm4gTWF0aC5mbG9vcihzYWZlTnVtIC8gMTAwMDAwMDAwMCkgKyBcIkJcIlxuICAgIH0gZWxzZSBpZiAoc2FmZU51bSA+PSAxMDAwMDAwKSB7XG4gICAgICByZXR1cm4gTWF0aC5mbG9vcihzYWZlTnVtIC8gMTAwMDAwMCkgKyBcIk1cIlxuICAgIH0gZWxzZSBpZiAoc2FmZU51bSA+PSAxMDAwKSB7XG4gICAgICByZXR1cm4gTWF0aC5mbG9vcihzYWZlTnVtIC8gMTAwMCkgKyBcIktcIlxuICAgIH1cbiAgICByZXR1cm4gTWF0aC5mbG9vcihzYWZlTnVtKS50b1N0cmluZygpXG4gIH0sXG5cbiAgZm9ybWF0TnVtYmVyUHJlY2lzZShudW06IG51bWJlciB8IHVuZGVmaW5lZCB8IG51bGwpOiBzdHJpbmcge1xuICAgIGNvbnN0IHNhZmVOdW0gPSB0eXBlb2YgbnVtID09PSBcIm51bWJlclwiICYmICFpc05hTihudW0pID8gbnVtIDogMFxuICAgIC8vIFJlbW92ZSB0cmFpbGluZyB6ZXJvcyBhbmQgdW5uZWNlc3NhcnkgZGVjaW1hbCBwbGFjZXNcbiAgICBpZiAoc2FmZU51bSA9PT0gMCkgcmV0dXJuIFwiMFwiXG4gICAgaWYgKHNhZmVOdW0gPj0gMSkgcmV0dXJuIHNhZmVOdW0udG9GaXhlZCgzKS5yZXBsYWNlKC9cXC4/MCskLywgXCJcIilcbiAgICByZXR1cm4gc2FmZU51bS50b0ZpeGVkKDYpLnJlcGxhY2UoL1xcLj8wKyQvLCBcIlwiKVxuICB9LFxuXG4gIGZvcm1hdFRpbWUoc2Vjb25kczogbnVtYmVyKTogc3RyaW5nIHtcbiAgICBjb25zdCBzYWZlU2Vjb25kcyA9IHR5cGVvZiBzZWNvbmRzID09PSBcIm51bWJlclwiICYmICFpc05hTihzZWNvbmRzKSA/IE1hdGguZmxvb3Ioc2Vjb25kcykgOiAwXG4gICAgY29uc3QgaG91cnMgPSBNYXRoLmZsb29yKHNhZmVTZWNvbmRzIC8gMzYwMClcbiAgICBjb25zdCBtaW51dGVzID0gTWF0aC5mbG9vcigoc2FmZVNlY29uZHMgJSAzNjAwKSAvIDYwKVxuICAgIGNvbnN0IHNlY3MgPSBzYWZlU2Vjb25kcyAlIDYwXG5cbiAgICBpZiAoaG91cnMgPiAwKSB7XG4gICAgICByZXR1cm4gYCR7aG91cnMudG9TdHJpbmcoKS5wYWRTdGFydCgyLCAnMCcpfToke21pbnV0ZXMudG9TdHJpbmcoKS5wYWRTdGFydCgyLCAnMCcpfToke3NlY3MudG9TdHJpbmcoKS5wYWRTdGFydCgyLCAnMCcpfWBcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGAke21pbnV0ZXMudG9TdHJpbmcoKS5wYWRTdGFydCgyLCAnMCcpfToke3NlY3MudG9TdHJpbmcoKS5wYWRTdGFydCgyLCAnMCcpfWBcbiAgICB9XG4gIH0sXG5cbiAgY2FuQ2xhaW1NaW5pbmcodXNlcjogVXNlcik6IGJvb2xlYW4ge1xuICAgIGlmICghdXNlci5pc01pbmluZyB8fCAhdXNlci5taW5pbmdTdGFydFRpbWUpIHJldHVybiBmYWxzZVxuICAgIFxuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KClcbiAgICBjb25zdCBtaW5pbmdEdXJhdGlvbiA9IE1hdGguZmxvb3IoKG5vdyAtIHVzZXIubWluaW5nU3RhcnRUaW1lKSAvIDEwMDApXG4gICAgXG4gICAgcmV0dXJuIG1pbmluZ0R1cmF0aW9uID49ICh1c2VyLm1pbkNsYWltVGltZSB8fCBHQU1FX0NPTkZJRy5NSU5fQ0xBSU1fVElNRSlcbiAgfSxcblxuICBnZXRNaW5pbmdEdXJhdGlvbih1c2VyOiBVc2VyKTogbnVtYmVyIHtcbiAgICBpZiAoIXVzZXIuaXNNaW5pbmcgfHwgIXVzZXIubWluaW5nU3RhcnRUaW1lKSByZXR1cm4gMFxuICAgIFxuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KClcbiAgICByZXR1cm4gTWF0aC5mbG9vcigobm93IC0gdXNlci5taW5pbmdTdGFydFRpbWUpIC8gMTAwMClcbiAgfSxcblxuICBjYWxjdWxhdGVQZW5kaW5nUmV3YXJkcyh1c2VyOiBVc2VyKTogbnVtYmVyIHtcbiAgICBjb25zdCBkdXJhdGlvbiA9IHRoaXMuZ2V0TWluaW5nRHVyYXRpb24odXNlcilcbiAgICBpZiAoZHVyYXRpb24gPT09IDApIHJldHVybiAwXG4gICAgXG4gICAgY29uc3QgeyBlYXJuZWQgfSA9IHRoaXMuY2FsY3VsYXRlTWluaW5nUmV3YXJkcyh1c2VyLCBkdXJhdGlvbilcbiAgICByZXR1cm4gZWFybmVkXG4gIH0sXG5cbiAgZ2V0UmVtYWluaW5nQ2xhaW1UaW1lKHVzZXI6IFVzZXIpOiBudW1iZXIge1xuICAgIGlmICghdXNlci5pc01pbmluZyB8fCAhdXNlci5taW5pbmdTdGFydFRpbWUpIHJldHVybiAwXG4gICAgXG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKVxuICAgIGNvbnN0IG1pbmluZ0R1cmF0aW9uID0gTWF0aC5mbG9vcigobm93IC0gdXNlci5taW5pbmdTdGFydFRpbWUpIC8gMTAwMClcbiAgICBjb25zdCBtaW5UaW1lID0gdXNlci5taW5DbGFpbVRpbWUgfHwgR0FNRV9DT05GSUcuTUlOX0NMQUlNX1RJTUVcbiAgICBcbiAgICByZXR1cm4gTWF0aC5tYXgoMCwgbWluVGltZSAtIG1pbmluZ0R1cmF0aW9uKVxuICB9LFxufSJdLCJuYW1lcyI6WyJHQU1FX0NPTkZJRyIsIlJFRkVSUkFMX0JPTlVTIiwiQkFTRV9NSU5JTkdfUkFURSIsIldFTENPTUVfQk9OVVMiLCJKQUNLUE9UX0NPT0xET1dOIiwiTUlOX0NMQUlNX1RJTUUiLCJNQVhfTUlOSU5HX1RJTUUiLCJEQUlMWV9NSU5JTkdfUkVXQVJEIiwiQ1JJVElDQUxfQ0hBTkNFIiwiSkFDS1BPVF9DSEFOQ0UiLCJNQVhfTEVWRUwiLCJYUF9QRVJfTEVWRUwiLCJEUlhfVE9fVUNfUkFURSIsIkJBU0VfWFBfUkVXQVJEIiwiUkVGRVJSQUxfWFBfQk9OVVMiLCJnYW1lTG9naWMiLCJjYWxjdWxhdGVNaW5pbmdSZXdhcmRzIiwidXNlciIsIm1pbmluZ0R1cmF0aW9uIiwiYmFzZVJhdGUiLCJtaW5pbmdSYXRlIiwiZWFybmVkIiwidHlwZSIsInhwIiwiTWF0aCIsImZsb29yIiwibWluaW5nU3BlZWRNdWx0aXBsaWVyIiwiYm9vc3RzIiwibWluaW5nU3BlZWRMZXZlbCIsIm1pbmluZ1JhdGVNdWx0aXBsaWVyIiwibWluaW5nUmF0ZUxldmVsIiwibWF4IiwiY2FsY3VsYXRlTGV2ZWwiLCJsZXZlbCIsInJlbWFpbmluZ1hQIiwidG90YWxYUE5lZWRlZCIsImdldFhwRm9yTGV2ZWwiLCJ4cEZvclRoaXNMZXZlbCIsImN1cnJlbnRYUCIsInhwRm9yTmV4dCIsImNhbGN1bGF0ZVJhbmsiLCJ0b3RhbEVhcm5lZCIsInJhbmtzIiwidGhyZXNob2xkIiwidGl0bGUiLCJpY29uIiwiY3VycmVudFJhbmsiLCJjdXJyZW50VGl0bGUiLCJjdXJyZW50SWNvbiIsIm5leHRSYW5rQXQiLCJpIiwibGVuZ3RoIiwicmFuayIsImdldEJvb3N0Q29zdCIsImJvb3N0VHlwZSIsImN1cnJlbnRMZXZlbCIsImJhc2VDb3N0IiwiQk9PU1RfQkFTRV9DT1NUUyIsInBvdyIsIkJPT1NUX0NPU1RfTVVMVElQTElFUiIsImdldE5leHRCb29zdFZhbHVlIiwibmV4dFNwZWVkTXVsdGlwbGllciIsImN1cnJlbnRUaW1lIiwibWluQ2xhaW1UaW1lIiwibmV4dFRpbWUiLCJmb3JtYXRUaW1lIiwiY3VycmVudFJhdGUiLCJuZXh0UmF0ZSIsImZvcm1hdE51bWJlclByZWNpc2UiLCJmb3JtYXROdW1iZXIiLCJudW0iLCJzYWZlTnVtIiwiaXNOYU4iLCJ0b1N0cmluZyIsInRvRml4ZWQiLCJyZXBsYWNlIiwic2Vjb25kcyIsInNhZmVTZWNvbmRzIiwiaG91cnMiLCJtaW51dGVzIiwic2VjcyIsInBhZFN0YXJ0IiwiY2FuQ2xhaW1NaW5pbmciLCJpc01pbmluZyIsIm1pbmluZ1N0YXJ0VGltZSIsIm5vdyIsIkRhdGUiLCJnZXRNaW5pbmdEdXJhdGlvbiIsImNhbGN1bGF0ZVBlbmRpbmdSZXdhcmRzIiwiZHVyYXRpb24iLCJnZXRSZW1haW5pbmdDbGFpbVRpbWUiLCJtaW5UaW1lIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/game-logic.ts\n"));

/***/ })

});